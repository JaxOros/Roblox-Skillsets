--[[
Anti-Exploit Framework
Author: JaxOros
Description:
A modular system for detecting and preventing exploit behavior in Roblox games.
Features:
- RemoteEvent validation (rate limits, argument checking)
- Movement monitoring (speed, teleport spikes, vertical checks)
- Suspicious GUI detection on the client
- Logging via print or webhook (ADDWEBHOOKHERE)
--]]

--[[
Services
--]]
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--[[
Module Table
--]]
local AntiExploit = {}
AntiExploit.__index = AntiExploit

--[[
Default configuration settings
These can be overridden using AntiExploit.configure()
--]]
local DEFAULTS = {
	Movement = {
		CheckInterval = 0.5,
		MaxSpeed = 80,
		SpeedBuffer = 1.4,
		TeleportDistance = 100,
		MaxVerticalSpeed = 80,
		ConsecutiveFlagsToTakeAction = 3,
	},
	Remote = {
		DefaultRateLimit = { burst = 5, per = 1 },
		DefaultArgLimit = 10,
	},
	Behavior = {
		AutoBan = false,
		AutoKick = false,
		FlagOnly = true,
	},
	Logging = {
		Print = true,
		Webhook = "ADDWEBHOOKHERE", -- <---- put your webhook here
	}
}

--[[
Internal state
--]]
local state = {
	players = {}, -- player -> monitoring data
	remoteProtected = {}, -- RemoteEvent -> config
	onFlaggedCallbacks = {},
	onConfirmedCallbacks = {},
	logger = nil,
	whitelist = {}, -- list of functions(player) -> boolean
}

--[[
log(level, message, data)
Prints and optionally posts to a webhook.
--]]
local function log(level, message, data)
	if DEFAULTS.Logging.Print then
		print(("[AntiExploit][%s] %s"):format(level, message))
	end

	local webhook = DEFAULTS.Logging.Webhook
	if webhook and webhook ~= "ADDWEBHOOKHERE" then
		task.spawn(function()
			local payload = {
				content = ("**[%s]** %s\n```json\n%s\n```"):format(level, message, HttpService:JSONEncode(data or {}))
			}
			local ok, err = pcall(function()
				HttpService:PostAsync(webhook, HttpService:JSONEncode(payload), Enum.HttpContentType.ApplicationJson)
			end)
			if not ok then
				-- don't spam errors if webhook fails
				if DEFAULTS.Logging.Print then
					warn("[AntiExploit] failed to post webhook:", err)
				end
			end
		end)
	end
end

--[[
Whitelist helpers
addWhitelist(fn) - add function(player) -> boolean to exemption checks
clearWhitelist() - clear whitelist
isWhitelisted(player) - internal check
--]]
function AntiExploit.addWhitelist(fn)
	if type(fn) == "function" then
		table.insert(state.whitelist, fn)
	end
end

function AntiExploit.clearWhitelist()
	state.whitelist = {}
end

local function isWhitelisted(player)
	for _, fn in ipairs(state.whitelist) do
		local ok, res = pcall(fn, player)
		if ok and res then return true end
	end
	return false
end

--[[
triggerFlagged(player, reason, data)
Notify flag listeners and log the event.
--]]
local function triggerFlagged(player, reason, data)
	log("FLAG", ("%s flagged for %s"):format(player and player.Name or "Unknown", reason), data)
	for _, cb in ipairs(state.onFlaggedCallbacks) do
		pcall(cb, player, reason, data)
	end
end

--[[
triggerConfirmed(player, reason, data)
Notify confirmed listeners and log the event.
--]]
local function triggerConfirmed(player, reason, data)
	log("CONFIRM", ("%s confirmed for %s"):format(player and player.Name or "Unknown", reason), data)
	for _, cb in ipairs(state.onConfirmedCallbacks) do
		pcall(cb, player, reason, data)
	end
end

--[[
configure(opts)
Override default settings. Pass a table with top-level keys from DEFAULTS.
--]]
function AntiExploit.configure(opts)
	if type(opts) ~= "table" then return end
	for k, v in pairs(opts) do
		if type(v) == "table" and type(DEFAULTS[k]) == "table" then
			for kk, vv in pairs(v) do DEFAULTS[k][kk] = vv end
		else
			DEFAULTS[k] = v
		end
	end
end

--[[
setLogger(fn)
Set a custom logger function(level, message, data). If not set, module uses default log().
--]]
function AntiExploit.setLogger(fn)
	if type(fn) == "function" then
		state.logger = fn
	else
		state.logger = nil
	end
end

--[[
onFlagged(callback)
Register callback(player, reason, data) for flagged events.
--]]
function AntiExploit.onFlagged(callback)
	if type(callback) == "function" then
		table.insert(state.onFlaggedCallbacks, callback)
	end
end

--[[
onConfirmed(callback)
Register callback(player, reason, data) for confirmed events.
--]]
function AntiExploit.onConfirmed(callback)
	if type(callback) == "function" then
		table.insert(state.onConfirmedCallbacks, callback)
	end
end

--[[
protectRemote(remoteEvent, config)
Protects a RemoteEvent by checking arg count, arg types (optional), and rate limits (optional).
Config keys:
- rate = { burst = N, per = seconds }
- maxArgs = N
- argTypes = { "number", "string", ... } (uses typeof())
- safeHandler = function(player, ...) -> invoked server-side if checks pass
- onViolation = function(player, reason, meta)
--]]
function AntiExploit.protectRemote(remoteEvent, config)
	assert(typeof(remoteEvent) == "Instance" and remoteEvent:IsA("RemoteEvent"),
		"protectRemote expects a RemoteEvent instance")

	local cfg = config or {}
	state.remoteProtected[remoteEvent] = cfg

	local rateCfg = cfg.rate or DEFAULTS.Remote.DefaultRateLimit
	local playerRates = setmetatable({}, { __mode = "k" }) -- weak keys

	remoteEvent.OnServerEvent:Connect(function(player, ...)
		if not player or not player.Parent then return end
		if isWhitelisted(player) then return end

		local args = { ... }

		-- arg count
		local maxArgs = cfg.maxArgs or DEFAULTS.Remote.DefaultArgLimit
		if #args > maxArgs then
			triggerFlagged(player, "TooManyArgs", { remote = remoteEvent.Name, count = #args, limit = maxArgs })
			if cfg.onViolation then pcall(cfg.onViolation, player, "TooManyArgs", args) end
			return
		end

		-- arg types
		if cfg.argTypes then
			for i, expected in ipairs(cfg.argTypes) do
				local actual = typeof(args[i])
				if expected and actual ~= expected then
					triggerFlagged(player, "InvalidArgType", { remote = remoteEvent.Name, index = i, expected = expected, got = actual })
					if cfg.onViolation then pcall(cfg.onViolation, player, "InvalidArgType", { index = i, expected = expected, got = actual }) end
					return
				end
			end
		end

		-- rate limiting
		local now = tick()
		local pdata = playerRates[player] or { times = {} }
		playerRates[player] = pdata

		local newTimes = {}
		for _, t in ipairs(pdata.times) do
			if now - t <= (rateCfg.per or 1) then
				table.insert(newTimes, t)
			end
		end
		table.insert(newTimes, now)
		pdata.times = newTimes

		if #newTimes > (rateCfg.burst or 5) then
			triggerFlagged(player, "RemoteRateLimitExceeded", { remote = remoteEvent.Name, burst = rateCfg.burst, per = rateCfg.per })
			if cfg.onViolation then pcall(cfg.onViolation, player, "RemoteRateLimitExceeded", { burst = rateCfg.burst, per = rateCfg.per }) end
			return
		end

		-- safe handler execution
		if cfg.safeHandler and type(cfg.safeHandler) == "function" then
			local ok, err = pcall(cfg.safeHandler, player, table.unpack(args))
			if not ok then
				log("ERROR", ("safeHandler error on %s: %s"):format(remoteEvent.Name, tostring(err)))
			end
		end
	end)

	log("INFO", ("Protected RemoteEvent: %s"):format(remoteEvent:GetFullName()))
end

--[[
monitorMovement()
Starts monitoring players' movement for abnormal speed and teleport spikes.
--]]
function AntiExploit.monitorMovement()
	Players.PlayerAdded:Connect(function(player)
		local playerConn
		playerConn = player.CharacterAdded:Connect(function(character)
			local hrp = character:WaitForChild("HumanoidRootPart", 5)
			if not hrp then return end

			local lastPos = hrp.Position
			local consecutiveFlags = 0
			local acc = 0
			local interval = DEFAULTS.Movement.CheckInterval

			local hbConn
			hbConn = RunService.Heartbeat:Connect(function(dt)
				if not player or not player.Parent or not character.Parent then
					if hbConn then hbConn:Disconnect() end
					return
				end

				acc = acc + dt
				if acc < interval then return end
				acc = 0

				local nowPos = hrp.Position
				local dist = (nowPos - lastPos).Magnitude
				local speed = dist / math.max(interval, 0.0001)

				-- speed check
				local speedLimit = DEFAULTS.Movement.MaxSpeed * DEFAULTS.Movement.SpeedBuffer
				if speed > speedLimit then
					consecutiveFlags = consecutiveFlags + 1
					triggerFlagged(player, "HighSpeed", { speed = speed, limit = speedLimit })
				end

				-- teleport spike
				if dist > DEFAULTS.Movement.TeleportDistance then
					consecutiveFlags = consecutiveFlags + 1
					triggerFlagged(player, "TeleportSpike", { distance = dist, threshold = DEFAULTS.Movement.TeleportDistance })
				end

				-- vertical speed
				local vertical = math.abs(nowPos.Y - lastPos.Y) / math.max(interval, 0.0001)
				if vertical > DEFAULTS.Movement.MaxVerticalSpeed then
					consecutiveFlags = consecutiveFlags + 1
					triggerFlagged(player, "VerticalSpeed", { vertical = vertical, threshold = DEFAULTS.Movement.MaxVerticalSpeed })
				end

				if consecutiveFlags >= DEFAULTS.Movement.ConsecutiveFlagsToTakeAction then
					triggerConfirmed(player, "MovementExploit", { consecutive = consecutiveFlags })
					consecutiveFlags = 0
				end

				lastPos = nowPos
			end)
		end)
	end)
end

--[[
startClientScanner()
Creates a RemoteEvent and injects a LocalScript into players to watch for suspicious GUIs.
Client LocalScript reports suspicious GUI insertions to the server.
--]]
function AntiExploit.startClientScanner()
	-- ensure report remote exists
	local reportEvent = ReplicatedStorage:FindFirstChild("AntiExploit_ReportEvent")
	if not reportEvent then
		reportEvent = Instance.new("RemoteEvent")
		reportEvent.Name = "AntiExploit_ReportEvent"
		reportEvent.Parent = ReplicatedStorage
	end

	-- server handler for client reports
	reportEvent.OnServerEvent:Connect(function(player, reportType, meta)
		if isWhitelisted(player) then return end
		triggerFlagged(player, reportType, meta)
	end)

	-- LocalScript source (comment style matches your example)
	local clientSource = [[
--[[
GUI Monitor Client Script
Author: JaxOros
Description:
Watches for suspicious GUI insertions or core changes in the PlayerGui,
to detect exploit UI injections.
--]]

local player = game.Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")
local rep = game:GetService("ReplicatedStorage")

local reportEvent = rep:WaitForChild("AntiExploit_ReportEvent", 5)
if not reportEvent then return end

--[[
SUSPICIOUS keywords list
Exploit GUIs often contain these substrings in their name or descendant names.
--]]
local SUSPICIOUS = {"dex", "infinite", "synapse", "script", "hack", "executor", "admin", "hub", "krnl"}

--[[
onGuiAdded(guiObj)
Checks names and descendants for suspicious keywords and reports to server.
--]]
local function onGuiAdded(guiObj)
	if not guiObj or not guiObj.Name then return end
	local nameLower = string.lower(guiObj.Name)
	for _, keyword in ipairs(SUSPICIOUS) do
		if string.find(nameLower, keyword, 1, true) then
			local ok, _ = pcall(function()
				reportEvent:FireServer("SuspiciousGUI", { Name = guiObj.Name })
			end)
			return
		end
	end

	for _, desc in ipairs(guiObj:GetDescendants()) do
		if desc and desc.Name then
			local dname = string.lower(desc.Name)
			for _, keyword in ipairs(SUSPICIOUS) do
				if string.find(dname, keyword, 1, true) then
					local ok, _ = pcall(function()
						reportEvent:FireServer("SuspiciousGUIDescendant", { Name = desc.Name, Parent = guiObj.Name })
					end)
					return
				end
			end
		end
	end
end

--[[
Connect monitor to existing and newly added descendants.
--]]
gui.DescendantAdded:Connect(onGuiAdded)

-- scan pre-existing children briefly to catch injections that occurred before listener attached
for _, child in ipairs(gui:GetDescendants()) do
	pcall(function() onGuiAdded(child) end)
end

print("[AntiExploit] GUI Monitor initialized for " .. tostring(player.Name))
]]

	-- injector: create a LocalScript for each player's PlayerScripts when they join
	Players.PlayerAdded:Connect(function(player)
		player.CharacterAdded:Connect(function()
			-- wait a tick to let PlayerScripts exist
			task.delay(0.5, function()
				local success, ps = pcall(function() return player:WaitForChild("PlayerScripts", 3) end)
				if not success or not ps then return end
				-- avoid duplicating the script
				if ps:FindFirstChild("AntiExploit_ClientGUIWatch") then return end
				local ls = Instance.new("LocalScript")
				ls.Name = "AntiExploit_ClientGUIWatch"
				ls.Source = clientSource
				ls.Parent = ps
			end)
		end)
	end)
end

--[[
start()
Starts all monitoring subsystems (movement, client GUI scanner).
Call this from a server script after configuring and protecting remotes.
--]]
function AntiExploit.start()
	log("INFO", "Starting Anti-Exploit Framework...")
	AntiExploit.monitorMovement()
	AntiExploit.startClientScanner()
end

--[[
protectAllRemotes(parent, commonConfig)
Helper to protect every RemoteEvent under a parent (e.g., ReplicatedStorage).
--]]
function AntiExploit.protectAllRemotes(parent, commonConfig)
	for _, desc in ipairs(parent:GetDescendants()) do
		if desc:IsA("RemoteEvent") then
			AntiExploit.protectRemote(desc, commonConfig)
		end
	end
end

--[[
Return module
--]]
return AntiExploit
